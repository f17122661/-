# ESP8266 NONOS 编程笔记

## GPIO 输入输出

### GPIO 输出库函数使用说明

- 管脚共亨选择宏定义
  
    > PIN_FUNC_SELECT(PIN_NAME,   FUNC);
- 功能选择器PERIPHS_IO_MUX_MTMS_U(不同的GPIO，该寄存器不同)
    > PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U,FUNC_GPIO14); 
    - 参数一是 GPIO引脚 的功能选择寄存器在该寄存器中传入不同的数值代表不同的功能 
    - 参数二传入FUNC_GPIO14 其实这个定义它的值是3 对应的功能是FUNCTION4 也就是MTMS端口的 普通GPIO口模式 详细GPIO 列表查询 ** ESP8266_Pin_List_0.xls **
- 输入输出设置
  
    >GPIO_DIS_OUTPUT(GPIO_ID_PIN(14));
- 引脚是否上拉 
    - 开启上拉
    > PIN_PULLUP_EN(PERIPHS_IO_MUX_MTMS_U);
    该语句作⽤是向PERIPHS_IO_MUX_MTMS_U的第7位写1。该位置1表⽰使能MTDI的上拉功能。
    - 关闭上拉
    > PIN_PULLUP_DIS(PERIPHS_IO_MUX_MTMS_U);
- GPIO 输出状态
    >GPIO_OUTPUT_SET(GPIO_ID_PIN(14), 1);
    >GPIO_OUTPUT_SET(GPIO_ID_PIN(14), 0);
- GPIO 输入状态
  
    > Uint8 level = GPIO_INPUT_GET(GPIO_ID_PIN(14))
### 配置步骤
1. 设置GPIO 工作模式
2. 设置GPIO 输入输出模式
3. 设置GPIO 输入输出状态

### GPIO 输入输出程序
``` CPP
#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "driver/gpio16.h"

uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void)
{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5; break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_32M_MAP_512_512: rf_cal_sec = 1024 - 5; break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5; break;
        default:rf_cal_sec = 0;break;
    }
    return rf_cal_sec;
}
void ICACHE_FLASH_ATTR user_rf_pre_init(void){}


void ICACHE_FLASH_ATTR
delay_ms(uint16 t)
{
	while(t--)
	{
		os_delay_us(1000);
	}
}


void ICACHE_FLASH_ATTR Led_Run_Task(void)
{
	static bool ledNegation;
	ledNegation = (!ledNegation);
	if (ledNegation) { gpio16_output_set(1); }
	else { gpio16_output_set(0); }
}

void ICACHE_FLASH_ATTR
Gpio_Init()
{
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(5));
	gpio16_output_conf();
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U,FUNC_GPIO14);
	PIN_PULLUP_EN(PERIPHS_IO_MUX_MTMS_U); //使能MTDI的上拉功能
	gpio16_output_set(1);
}
/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uint8 time = 0;
	uint8 *str = "system start!";
	uart_init(BIT_RATE_115200, BIT_RATE_115200);
	Gpio_Init();
    os_printf("SDK version:%s\n", system_get_sdk_version());
    uart0_tx_buffer(str, strlen(str));
    while(1)
    {
    	 uint8 level = GPIO_INPUT_GET(GPIO_ID_PIN(5));
    	 if(level == 1)
    	 {
    		 ;

    	 }
    	 else
    	 {
             Led_Run_Task();
    		 os_printf("Key Status:%d\n", level);
    		 delay_ms(200);
    	 }

    system_soft_wdt_feed();
    // 这里应该添加喂狗程序 不然会出现复位的情况
    }

}
```
## GPIO_EXIT

### GPIO 输出库函数使用说明

1. 选择管脚
   
    >PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U,FUNC_GPIO5);
2. 设置对应管脚为输入模式
   
    > GPIO_DIS_OUTPUT(GPIO_ID_PIN(5)) ;
3. 设置对应中断的触发方式 触发方式有5种
    >gpio_pin_intr_state_set(GPIO_ID_PIN(2),GPIO_PIN_INTR_NEGEDGE);
    ``` CPP
    typedef enum {
        GPIO_PIN_INTR_DISABLE = 0,//不使用中断
        GPIO_PIN_INTR_POSEDGE = 1,//上升沿
        GPIO_PIN_INTR_NEGEDGE = 2,//下降沿
        GPIO_PIN_INTR_ANYEDGE = 3,//双边沿
        GPIO_PIN_INTR_LOLEVEL = 4,//低电平
        GPIO_PIN_INTR_HILEVEL = 5//高电平
    } GPIO_INT_TYPE;
    ```
4. 设置中断的回调函数 
   
    >ETS_GPIO_INTR_ATTACH(ext_interrupt_callback,NULL);
5. 开启中断
   
    >ETS_GPIO_INTR_ENABLE();
6. 回调函数的编写
   
    >void ext_interrupt_callback(void *arg)
### 程序
``` CPP
#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "driver/gpio16.h"

uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void)
{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5; break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_32M_MAP_512_512: rf_cal_sec = 1024 - 5; break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5; break;
        default:rf_cal_sec = 0;break;
    }
    return rf_cal_sec;
}
void ICACHE_FLASH_ATTR user_rf_pre_init(void){}


void ICACHE_FLASH_ATTR
delay_ms(uint16 t)
{
	while(t--)
	{
		os_delay_us(1000);
	}
}


void ICACHE_FLASH_ATTR Led_Run_Task(void)
{
	static bool ledNegation;
	ledNegation = (!ledNegation);
	if (ledNegation) { gpio16_output_set(1); }
	else { gpio16_output_set(0); }
}

void ICACHE_FLASH_ATTR
Gpio_Init()
{
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(5));
	gpio16_output_conf();
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U,FUNC_GPIO14);
	PIN_PULLUP_EN(PERIPHS_IO_MUX_MTMS_U); //使能MTDI的上拉功能
	gpio16_output_set(1);
}

void ext_interrupt_callback()
{
	uint32	gpio_status;
	gpio_status	= GPIO_REG_READ(GPIO_STATUS_ADDRESS); //外部中断服务函数只有一个 判断进来的是哪个IO口
	GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);//清除中断标志位 写1清除
	if(((gpio_status >> 5) & 0x01) == 1) //判断是哪个中断脚
	{
		Led_Run_Task();
	}
}
void ICACHE_FLASH_ATTR	GPIO_EXIT_Init(void)
{

	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U,FUNC_GPIO5); //选择GPIO5 工作在复用模式
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(5)); // 设置GPIO5为输入模式
	gpio_pin_intr_state_set(GPIO_ID_PIN(5),GPIO_PIN_INTR_NEGEDGE); //设置外部中断下降沿触发
	ETS_GPIO_INTR_ATTACH((ets_isr_t)ext_interrupt_callback,NULL);//设置外部中断回调函数
	ETS_GPIO_INTR_ENABLE();//开启外部中断

}
/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uint8 time = 0;
	uint8 *str = "system start!";
	uart_init(BIT_RATE_115200, BIT_RATE_115200);
	Gpio_Init();
    GPIO_EXIT_Init();
    os_printf("SDK version:%s\n", system_get_sdk_version());
    uart0_tx_buffer(str, strlen(str));
    while(1)
    {
    system_soft_wdt_feed();
    // 这里应该添加喂狗程序 不然会出现复位的情况
    }
}
```

## Sw_Timer & Hw_Timer

**这个特别要注意的就是 不要在初始话那边写while(1) 不然会影响 软件定时器的 硬件定时器无影响**

### Sw_Timer 相关函数说明

1. 先宏定义一个定时器结构体：
   
    >static os_timer_t os_timer;
2. 对于同一个定时器不能同时使用，所以我在初始化前先关闭该定时器。
   
    >os_timer_disarm( &os_timer );
3. 初始化定时器的回调函数，即每次定时任务函数。下图是函数os_timer_setfn()有关说明。我这里的定时器回调函数是Led_Task_Run ()。
   
    >os_timer_setfn( &os_timer, (ETSTimerFunc *) ( Led_Task_Run ), NULL );
4. 开始执行我们的定时器 参数1 哪个定时器 参数二 定时MS 参数三 是否重载
   
    >os_timer_arm( &os_timer, 500, true );
### 程序
``` CPP

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "driver/gpio16.h"

uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void)
{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5; break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_32M_MAP_512_512: rf_cal_sec = 1024 - 5; break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5; break;
        default:rf_cal_sec = 0;break;
    }
    return rf_cal_sec;
}
void ICACHE_FLASH_ATTR user_rf_pre_init(void){}

/** 定时器结构体 */
static os_timer_t os_timer;


/** LED操作命令 */
void ICACHE_FLASH_ATTR Led_Cmd(bool status ){
    if (status == true ) {
    	GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0);
    } else {
    	GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1);
    }
}



void Led_Task_Run(void){

	static bool status = false;
      if ( status == true ) {
	        status = false;
	    } else  {
	        status = true;
	    }
     Led_Cmd( status );
}

void ICACHE_FLASH_ATTR user_init(void)//初始化
{

        // 设置串口0和串口1的波特率
        uart_init(57600, 57600);

   	    PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12);
   	    Led_Cmd(false);

       /** 关闭该定时器 */
       os_timer_disarm( &os_timer );
       /** 配置该定时器回调函数 */
       os_timer_setfn( &os_timer, (ETSTimerFunc *) ( Led_Task_Run ), NULL );
       /** 启动该定时器 */
       os_timer_arm( &os_timer, 500, true );
}

```

### Hw_Timer 相关函数说明
**硬件中断定时器器的回调函数定义，请勿添加 ICACHE_FLASH_ATTR**
1. 选择定时器计数器时钟源
    *第一个参数0使用的是FRC1_SOURCE，如果是1则为NMI_SOURCE类型，第二个参数是否自动填充，也就是是否重复。*
    
    >hw_timer_init(0, 1);
2. 设置定时器的回调函数
   
    >hw_timer_set_func(HwTimeInterruptCallBack);
3. 设置定时时间 这里的入口参数是us级别
   
    >hw_timer_arm(500);
### Hw_Timer 程序
``` CPP

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "driver/gpio16.h"

uint32 ICACHE_FLASH_ATTR user_rf_cal_sector_set(void)
{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5; break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;break;
        case FLASH_SIZE_32M_MAP_512_512: rf_cal_sec = 1024 - 5; break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5; break;
        default:rf_cal_sec = 0;break;
    }
    return rf_cal_sec;
}
void ICACHE_FLASH_ATTR user_rf_pre_init(void){}

void ICACHE_FLASH_ATTR Led_Run_Task(void)
{
	static bool ledNegation;
	os_printf("LED_Task\n");
	ledNegation = (!ledNegation);
	if (ledNegation) { gpio16_output_set(1); }
	else { gpio16_output_set(0); }
}

void HwTimeInterruptCallBack(void)
{
	Led_Run_Task();

}
void ICACHE_FLASH_ATTR Hw_Time_init(void)
{
	hw_timer_init(0, 1);
	hw_timer_set_func(HwTimeInterruptCallBack);
	hw_timer_arm(500*1000);
}
void ICACHE_FLASH_ATTR
Gpio_Init()
{
	GPIO_DIS_OUTPUT(GPIO_ID_PIN(5));
	gpio16_output_conf();
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U,FUNC_GPIO14);
	PIN_PULLUP_EN(PERIPHS_IO_MUX_MTMS_U); //使能MTDI的上拉功能
	gpio16_output_set(1);

}

/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uint8 time = 0;
	uint8 *str = "system start!";
	uart_init(BIT_RATE_115200, BIT_RATE_115200);
	Gpio_Init();
	Hw_Time_init();
    os_printf("SDK version:%s\n", system_get_sdk_version());
    uart0_tx_buffer(str, strlen(str));

    while(1)
    {
    	 uint8 level = GPIO_INPUT_GET(GPIO_ID_PIN(5));
    	 if(level == 1)
    	 {
    		 ;

    	 }
    	 else
    	 {
    		 os_printf("Key Status:%d\n", level);
    		 delay_ms(200);
    	 }

    system_soft_wdt_feed();
    // 这里应该添加喂狗程序 不然会出现复位的情况
    }

}
```

## PWM 输出
### Sw_Timer 相关函数说明
1. 初始化pwm（周期，占空比，3通道数）
    ``` CPP
    uint32 pwm_duty_init[3]={0};
    
    //初始化 PWM，1000周期,pwm_duty_init占空比,3通道数
    uint32 io_info[][3]={
        {PERIPHS_IO_MUX_MTDI_U,FUNC_GPIO12,12},
        {PERIPHS_IO_MUX_MTCK_U,FUNC_GPIO13,13},
        {PERIPHS_IO_MUX_MTDO_U,FUNC_GPIO15,15}
        };
    //开始初始化
    pwm_init(1000,pwm_duty_init,3,io_info);
    ```
2. 开启PWM *每次对PWM 寄存器进行配置后都要用这个函数才能*
   
    >void pwm_start(void);
3. pwm_set_duty *设置每一路的 PWM 周期，单位： μs。例如， 1KHz PWM，参数为 1000μs*
   
    >
### 程序
    ``` CPP
    #include "ets_sys.h"
    #include "osapi.h"
    #include "user_light.h"
    #include "gpio.h"
    #include "user_interface.h"
    
    static os_timer_t os_timer;
    /** 呼吸灯运行程序 */
    void ESP8266_PWM_RUN( void )
    {
        /** PWM占空比变量 */
        static u8 set_duty = 0;
    
        /** 占空比加减标志 */
        static bool f = true;
        if ( f == true )
        {
            if ( ++set_duty >= 100 )
            {
                f = false;
            }
        }
        else
        {
            if ( --set_duty <= 0 )
            {
                f = true;
            }
        }
    
        /** 更新PWM通道0的占空比 */
        pwm_set_duty( set_duty, 0 );
        pwm_start();
    }
    
    /** 初始化PWM配置、系统定时器配置 */
    void ESP8266_PWM_Init( void )
    {
    //    struct pwm_param pwm_config;
        uint32_t io_info[ ][ 3 ] =
        {
            { PWM_1_OUT_IO_MUX, PWM_1_OUT_IO_FUNC, PWM_1_OUT_IO_NUM }, 
        };
    
        uint32_t duty[ ] = { 0 };
    
    //    pwm_config.duty[ 0 ] = 0;
    //    pwm_config.freq = 0;
    //    pwm_config.period = 1000;
    
        pwm_init( 1000, duty, 1, io_info );
    
        /** 配置定时器每30ms执行一次ESP8266_PWM_RUN()函数 */
        os_timer_disarm( &os_timer );
        os_timer_setfn( &os_timer, (ETSTimerFunc *) ( ESP8266_PWM_RUN ), NULL );
        os_timer_arm( &os_timer, 30, true );
    }
    
    /** 用户初始化程序，根据测试该程序只运行一次 */
    void user_init(void)
    {
        ESP8266_PWM_Init();
    }
    ```




## AP mode

1. 设置ESP8266模式 
   
    >wifi_set_opmode(0x02); //0x02 是AP模式
2. 设置AP 网关 子网掩码等参数
   
    >wifi_set_ip_info(SOFTAP_IF,&info);
3. 设置AP 热点参数
   
    >wifi_softap_set_config(&AP_Config);
4. 设置AP DHCP服务
   
    >wifi_softap_set_dhcps_lease(&dhcp_Config);
5. 开启DHCP 服务
   
    >wifi_softap_dhcps_start();

### IP地址 子网掩码 网关 结构体初始化
``` CPP
struct ip_info info;
IP4_ADDR(&info.ip,192,168,1,1); //设置AP自己的地址
IP4_ADDR(&info.gw,192,168,1,1);// 设置网关地址
IP4_ADDR(&info.netmask,255,255,255,0);//设置子网掩码
wifi_set_ip_info(SOFTAP_IF,&info);//作为AP模式 主机的IP NETMASK GATEWAY 初始化
```
### DHCP 服务初始化 设置 IP 池
``` CPP
struct dhcps_lease dhcp_Config;
wifi_softap_dhcps_stop();
dhcp_Config.enable = true; //开启DHCP 服务
IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1); //初始化DHCP 池开始地址
IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);//结束地址
wifi_softap_set_dhcps_lease(&dhcp_Config);//开启DHCP服务
wifi_softap_dhcps_start();//开启DHCP
//wifi_softap_dhcps_stop();//关闭DHCP
```
### 初始化AP 信息 SSID PASSWD 等
``` CPP
struct softap_config AP_Config;

os_memset(&AP_Config,0,sizeof(struct softap_config));//给AP_Config 结构体地址开辟初始化为0的内存空间
os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);//设置AP_Config的SSID名字是 ESP8266_AP_SSID
os_strcpy(AP_Config.password,ESP8266_AP_PASS);//设置AP_Config的PASSWD密码是 ESP8266_AP_PASS
AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
AP_Config.channel = 1;
AP_Config.authmode = AUTH_WPA2_PSK;
AP_Config.ssid_hidden = 0;
AP_Config.max_connection = 4;
AP_Config.beacon_interval = 100;
wifi_softap_set_config(&AP_Config);
```

### 查询AP 已链接的个数 和 链接信息
- 获取自身的IP地址
    ``` CPP
    wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);
	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
    ```
- 获取client的IP信息 这个要注意 要加入 queue.h  消息列队头文件
    ``` CPP
    struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station); //一定要释放掉这个内存 不然一直复位
		station	=	next_station;
	}
    ```
- 获取链接个数
    ``` CPP
    	os_printf("Number of devices connected to this WIFI = %d\n",wifi_softap_get_station_num());
    ```

### 程序
``` CPP
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"

#define ProjectName "AP_MODE"

#define ESP8266_AP_SSID "ouo`"
#define ESP8266_AP_PASS "12345678a"

os_timer_t OS_Timer_1;

void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR AP_Init()
{
	struct softap_config AP_Config;
	struct dhcps_lease dhcp_Config;
	struct ip_info info;

	IP4_ADDR(&info.ip,192,168,1,1);
	IP4_ADDR(&info.gw,192,168,1,1);
	IP4_ADDR(&info.netmask,255,255,255,0);

	os_memset(&AP_Config,0,sizeof(struct softap_config));
	os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);
	os_strcpy(AP_Config.password,ESP8266_AP_PASS);

	AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
	AP_Config.channel = 1;
	AP_Config.authmode = AUTH_WPA2_PSK;
	AP_Config.ssid_hidden = 0;
	AP_Config.max_connection = 4;
	AP_Config.beacon_interval = 100;


	dhcp_Config.enable = true;
	IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1);
	IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);

	//dhcp_Config.start_ip = (struct ip_addr)ipaddr_addr(start_ip);
	//dhcp_Config.end_ip = (struct ip_addr)ipaddr_addr(end_ip);


	wifi_softap_dhcps_stop();
	wifi_set_opmode(0x02);
	wifi_set_ip_info(SOFTAP_IF,&info);
	wifi_softap_set_dhcps_lease(&dhcp_Config);
	wifi_softap_set_config(&AP_Config);
	wifi_softap_dhcps_start();

}

void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];


	struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}



	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}

	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);
	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;

	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);
	os_printf("Number of devices connected to this WIFI = %d\n",wifi_softap_get_station_num());
}

void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 1000, 1);

}


/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uint8 C_Task = 0;
	uint8 Message_Type = 1; //
	uint8 Message_pare = 'A';
	uart_init(115200,115200); //��ʼ��������
	AP_Init();
	OS_Time_Init();
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());


}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}




void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}


```

## AP UDP SERVER

**控制方式用的定时器 等待 client 链接进来 进来后 关闭定时器 等待发送**

1. 设置AP 基于上面的AP 模式配置

2. 建立 UDP Receive 回调函数 这个是接受成功 回调
    ``` CPP
    void ICACHE_FLASH_ATTR udp_server_recv_cb(void *arg, char *pdata, unsigned short len)
    {
        struct	espconn	*pesp_conn	=	arg; //获取回调函数入口的 UDP 属性结构体
        espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));//返回接受到的数据
        //remot_info	*premot	=	NULL;
    }
    ```
3. 建立 UDP Send 回调函数 这个是 发送成功 回调
    ``` CPP
        os_printf("udp_server_send_success!\r\n");
    ```
4. 配置UDP 服务器
    ``` CPP
    struct espconn udp_server_conn; //声明UPD服务器初始化结构体
    void ICACHE_FLASH_ATTR User_UDPServer_Init(void)
    {
        udp_server_conn.type = ESPCONN_UDP;
        udp_server_conn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp)); //开辟一个内存给 UDP 做初始化
        udp_server_conn.proto.udp->local_port = 8266;// UDP服务器端口
        espconn_regist_sentcb(&udp_server_conn,udp_server_send_cb); //建立回调
        espconn_regist_recvcb(&udp_server_conn,udp_server_recv_cb); //建立回调
        espconn_create(&udp_server_conn);//打开UDP SERVER
    }
    ```
###  程序
``` cpp
    /* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_MODE"

#define ESP8266_AP_SSID "ouo`"
#define ESP8266_AP_PASS "12345678a"

os_timer_t OS_Timer_1;

void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR AP_Init()
{
	struct softap_config AP_Config;
	struct dhcps_lease dhcp_Config;
	struct ip_info info;

	IP4_ADDR(&info.ip,192,168,1,1);
	IP4_ADDR(&info.gw,192,168,1,1);
	IP4_ADDR(&info.netmask,255,255,255,0);

	os_memset(&AP_Config,0,sizeof(struct softap_config));
	os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);
	os_strcpy(AP_Config.password,ESP8266_AP_PASS);

	AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
	AP_Config.channel = 1;
	AP_Config.authmode = AUTH_WPA2_PSK;
	AP_Config.ssid_hidden = 0;
	AP_Config.max_connection = 4;
	AP_Config.beacon_interval = 100;


	dhcp_Config.enable = true;
	IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1);
	IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);

	wifi_softap_dhcps_stop();
	wifi_set_opmode(0x02);
	wifi_set_ip_info(SOFTAP_IF,&info);
	wifi_softap_set_dhcps_lease(&dhcp_Config);
	wifi_softap_set_config(&AP_Config);
	wifi_softap_dhcps_start();

}
void ICACHE_FLASH_ATTR udp_server_send_cb(void *arg)
{

	os_printf("udp_server_send_success!\r\n");

}
void ICACHE_FLASH_ATTR udp_server_recv_cb(void *arg, char *pdata, unsigned short len)
{
 struct	espconn	*pesp_conn	=	arg;
 remot_info	*premot	=	NULL;
 if	(espconn_get_connection_info(pesp_conn,&premot,0)	==	ESPCONN_OK){
	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
	 //pesp_conn->proto.tcp->remote_port	=	58050;
	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
	 espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));
 }
 os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
 os_printf("udp_server_recvdata:%s\r\n",pdata);
}


struct espconn udp_server_conn;


void ICACHE_FLASH_ATTR User_UDPServer_Init(void)
{
	udp_server_conn.type = ESPCONN_UDP;
	udp_server_conn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp));
	udp_server_conn.proto.udp->local_port = 8266;
	//udp_server_conn.proto.udp->remote_port = remoute_port;
	espconn_regist_sentcb(&udp_server_conn,udp_server_send_cb);
	espconn_regist_recvcb(&udp_server_conn,udp_server_recv_cb);
	espconn_create(&udp_server_conn);
}


void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 client_num = 0;
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];


	struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}

	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}

	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);

	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
	client_num = wifi_softap_get_station_num();
	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);
	os_printf("Number of devices connected to this WIFI = %d\n",client_num);
	if(client_num !=0)
	{
		os_printf("已经链接请发数据!\r\n");
		//os_timer_disarm(&OS_Timer_1);

	}

}

void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 1000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //锟斤拷始锟斤拷锟斤拷锟斤拷锟斤拷
	//delay_ms(1000);
	os_printf("\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());

	AP_Init();
	OS_Time_Init();
	User_UDPServer_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}




void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```


## AP UDP Client

**控制方式用的定时器 定时去链接 UDP SERVER 并发送**

1. 设置AP 基于上面的AP 模式配置

2. 建立 UDP Receive 回调函数 这个是接受成功 回调
    ``` CPP
    void ICACHE_FLASH_ATTR udp_server_recv_cb(void *arg, char *pdata, unsigned short len)
    {
        struct	espconn	*pesp_conn	=	arg; //获取回调函数入口的 UDP 属性结构体
        espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));//返回接受到的数据
        //remot_info	*premot	=	NULL;
    }
    ```
3. 建立 UDP Send 回调函数 这个是 发送成功 回调
    ``` CPP
        os_printf("udp_server_send_success!\r\n");
    ```
4. 配置UDP 服务
    ``` CPP
    struct espconn udp_server_conn; //声明UPD服务器初始化结构体
    void ICACHE_FLASH_ATTR User_UDPServer_Init(void)
    {
        udp_server_conn.type = ESPCONN_UDP;
        udp_server_conn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp)); //开辟一个内存给 UDP 做初始化
        udp_server_conn.proto.udp->local_port = 8266;// UDP服务器端口
        udp_server_conn.proto.udp->remote_port = 6776;
        udp_server_conn.proto.udp->remote_ip[0] = 192;
        udp_server_conn.proto.udp->remote_ip[1] = 168;
        udp_server_conn.proto.udp->remote_ip[2] = 1;
        udp_server_conn.proto.udp->remote_ip[3] = 2;
        espconn_regist_sentcb(&udp_server_conn,udp_server_send_cb); //建立回调
        espconn_regist_recvcb(&udp_server_conn,udp_server_recv_cb); //建立回调   
    }
    ```
4. 定时器配置回调函数 在这里面做链接并发送
    ``` cpp
    void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
    {
        struct ip_info ST_ESP8266_IP;
        struct station_info * station = wifi_softap_get_station_info();
        struct station_info * next_station;
        uint8 client_num = 0;
        u8  ESP8266_IP[4];
        switch(wifi_get_opmode())
        {
            case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
            case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
            case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
        }
        wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);
        ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
        ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
        ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
        ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
        os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);

        while (station) {
            os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d\r\n", MAC2STR(station->bssid),
            IP2STR(&station->ip));
            station = STAILQ_NEXT(station, next);
            os_free(station);
            station	=	next_station;
        }
        client_num = wifi_softap_get_station_num();
        os_printf("Number of devices connected to this WIFI = %d\n",client_num);

        if(client_num != 0)
        {
            os_printf("已经链接请发数据!\r\n");

            switch(espconn_create(&udp_server_conn))
            {
                case ESPCONN_ISCONN:

                    espconn_sent(&udp_server_conn,	"led on",	os_strlen("led on"));

                    break;
                case ESPCONN_MEM:

                    break;
                case ESPCONN_ARG:
                    os_printf("UDP CONNECT FAILD!!");

                    break;
                default:break;

            }
            //os_timer_disarm(&OS_Timer_1);

        }

    }

    void OS_Time_Init(void)
    {
        os_timer_disarm(&OS_Timer_1);
        os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
        os_timer_arm(&OS_Timer_1, 5000, 1);
    }
    ```
###  程序
``` cpp
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_MODE"

#define ESP8266_AP_SSID "ouo`"
#define ESP8266_AP_PASS "12345678a"

os_timer_t OS_Timer_1;

void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR AP_Init()
{
	struct softap_config AP_Config;
	struct dhcps_lease dhcp_Config;
	struct ip_info info;

	IP4_ADDR(&info.ip,192,168,1,1);
	IP4_ADDR(&info.gw,192,168,1,1);
	IP4_ADDR(&info.netmask,255,255,255,0);

	os_memset(&AP_Config,0,sizeof(struct softap_config));
	os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);
	os_strcpy(AP_Config.password,ESP8266_AP_PASS);

	AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
	AP_Config.channel = 1;
	AP_Config.authmode = AUTH_WPA2_PSK;
	AP_Config.ssid_hidden = 0;
	AP_Config.max_connection = 4;
	AP_Config.beacon_interval = 100;


	dhcp_Config.enable = true;
	IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1);
	IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);

	wifi_softap_dhcps_stop();
	wifi_set_opmode(0x02);
	wifi_set_ip_info(SOFTAP_IF,&info);
	wifi_softap_set_dhcps_lease(&dhcp_Config);
	wifi_softap_set_config(&AP_Config);
	wifi_softap_dhcps_start();

}
void ICACHE_FLASH_ATTR udp_server_send_cb(void *arg)
{

	os_printf("udp_client_send_success!\r\n");

}
void ICACHE_FLASH_ATTR udp_server_recv_cb(void *arg, char *pdata, unsigned short len)
{
 struct	espconn	*pesp_conn	=	arg;
 remot_info	*premot	=	NULL;
 if	(espconn_get_connection_info(pesp_conn,&premot,0)	==	ESPCONN_OK){
	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
	 //pesp_conn->proto.tcp->remote_port	=	58050;
	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
	 espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));
 }
 os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
 os_printf("udp_server_recvdata:%s\r\n",pdata);
}


struct espconn udp_server_conn;

/*
 * ESPCONN_ARG：未找到参数 espconn 对应的 UDP 连接
 * ESPCONN_MEM：空间不足
 * ESPCONN_ISCONN：连接已经建立
 */
void ICACHE_FLASH_ATTR User_UDPServer_Init(void)
{
	udp_server_conn.type = ESPCONN_UDP;
	udp_server_conn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp));
	udp_server_conn.proto.udp->local_port = 8266;
	udp_server_conn.proto.udp->remote_port = 6776;
	udp_server_conn.proto.udp->remote_ip[0] = 192;
	udp_server_conn.proto.udp->remote_ip[1] = 168;
	udp_server_conn.proto.udp->remote_ip[2] = 1;
	udp_server_conn.proto.udp->remote_ip[3] = 2;
	espconn_regist_sentcb(&udp_server_conn,udp_server_send_cb);
	espconn_regist_recvcb(&udp_server_conn,udp_server_recv_cb);
}


void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 client_num = 0;
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];
	struct station_info * station = wifi_softap_get_station_info();
	struct station_info * next_station;


	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}
	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);
	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);

	while (station) {
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d\r\n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}
	client_num = wifi_softap_get_station_num();
	os_printf("Number of devices connected to this WIFI = %d\n",client_num);

	if(client_num != 0)
	{
		os_printf("已经链接请发数据!\r\n");

		switch(espconn_create(&udp_server_conn))
		{
			case ESPCONN_ISCONN:

				espconn_sent(&udp_server_conn,	"led on",	os_strlen("led on"));

				break;
			case ESPCONN_MEM:

				break;
			case ESPCONN_ARG:
				os_printf("UDP CONNECT FAILD!!");

				break;
			default:break;

		}
		//os_timer_disarm(&OS_Timer_1);

	}

}

void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 5000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //锟斤拷始锟斤拷锟斤拷锟斤拷锟斤拷
	//delay_ms(1000);
	os_printf("\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());

	AP_Init();
	OS_Time_Init();
	User_UDPServer_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}




void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```

## AP TCP Server

1. 设置AP 热点

2. 配置 TCP 发送成功回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR WIFISendCallBack(void *arg)
    {
        os_printf("\nESP8266_WIFI_Send_OK\n");
    }
    ```
3. 配置 TCP 接受成功回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR WIFIRecvCallBack(void *arg, char * pdata, unsigned short len)
    {
        struct	espconn	*pesp_conn = arg;
        sint8 connectionInfoStatus;
        espconn_send(pesp_conn,	pdata,	os_strlen(pdata)
    }
    ```
4. 配置 TCP 连接成功回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR TCPConnectCallBack(void *arg)
    {
        struct	espconn	*pesp_conn = arg;

        espconn_regist_sentcb((struct espconn *)arg, WIFISendCallBack);
        espconn_regist_recvcb(pesp_conn, WIFIRecvCallBack);
        espconn_regist_disconcb((struct espconn *)arg,TCPDisconnectBreakCallBack);

        os_printf("\n--------------- ESP8266_TCP_Connect_OK ---------------\n");
    }

    ```
5. 配置 TCP 链接中打断回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR TCPReconnectBreakCallBack(void *arg,sint8 err)
    {
        os_printf("\nESP8266_TCP_Disconnect_OK\n");
    }

    ```
6. 配置 TCP 链接失败回调函数
    ``` cpp
   void ICACHE_FLASH_ATTR TCPDisconnectBreakCallBack(void *arg)
    {
        os_printf("\nESP8266_TCP_Disconnect_OK\n");
    }
   ```
7. 配置TCP SERVER
    ``` cpp
    void ICACHE_FLASH_ATTR User_TCPServer_Init(void)
    {

        TCPServerConn.type = ESPCONN_TCP;
        TCPServerConn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));
        TCPServerConn.proto.tcp->local_port = 8266; //本都端口
        espconn_regist_connectcb(&TCPServerConn,TCPConnectCallBack); //连接成功回调
        espconn_regist_reconcb(&TCPServerConn,TCPReconnectBreakCallBack);// 链接失败回调
        espconn_accept(&TCPServerConn);//打开server
        espconn_regist_time(&TCPServerConn, 300, 0);//设置client 链接时间
    }
   ```
### 程序
``` cpp
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_TCP_SERVER"

#define ESP8266_AP_SSID "AP_TCP_SERVER"
#define ESP8266_AP_PASS "12345678a"

os_timer_t OS_Timer_1;

void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR AP_Init()
{
	struct softap_config AP_Config;
	struct dhcps_lease dhcp_Config;
	struct ip_info info;

	IP4_ADDR(&info.ip,192,168,1,1);
	IP4_ADDR(&info.gw,192,168,1,1);
	IP4_ADDR(&info.netmask,255,255,255,0);

	os_memset(&AP_Config,0,sizeof(struct softap_config));
	os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);
	os_strcpy(AP_Config.password,ESP8266_AP_PASS);

	AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
	AP_Config.channel = 1;
	AP_Config.authmode = AUTH_WPA2_PSK;
	AP_Config.ssid_hidden = 0;
	AP_Config.max_connection = 4;
	AP_Config.beacon_interval = 100;


	dhcp_Config.enable = true;
	IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1);
	IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);

	wifi_softap_dhcps_stop();
	wifi_set_opmode(0x02);
	wifi_set_ip_info(SOFTAP_IF,&info);
	wifi_softap_set_dhcps_lease(&dhcp_Config);
	wifi_softap_set_config(&AP_Config);
	wifi_softap_dhcps_start();

}


void ICACHE_FLASH_ATTR WIFISendCallBack(void *arg)
{
	os_printf("\nESP8266_WIFI_Send_OK\n");
}

void ICACHE_FLASH_ATTR WIFIRecvCallBack(void *arg, char * pdata, unsigned short len)
{
	struct	espconn	*pesp_conn = arg;
	remot_info	*premot	=	NULL;
	sint8 connectionInfoStatus;
	connectionInfoStatus = espconn_get_connection_info(pesp_conn,&premot,0);
	if(connectionInfoStatus	==	ESPCONN_OK){
	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
	 os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
	}else if(connectionInfoStatus == ESPCONN_ARG)
	{
		os_printf("connectionInfoStatus:ESPCONN_ARG\r\n");

	}

	//os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
	os_printf("TCP_server_recvdata:%s\r\n",pdata);
	espconn_send(pesp_conn,	pdata,	os_strlen(pdata));
}



void ICACHE_FLASH_ATTR TCPReconnectBreakCallBack(void *arg,sint8 err)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
}



void ICACHE_FLASH_ATTR TCPDisconnectBreakCallBack(void *arg)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
}



void ICACHE_FLASH_ATTR TCPConnectCallBack(void *arg)
{
	struct	espconn	*pesp_conn = arg;

	espconn_regist_sentcb((struct espconn *)arg, WIFISendCallBack);
	espconn_regist_recvcb(pesp_conn, WIFIRecvCallBack);
	espconn_regist_disconcb((struct espconn *)arg,TCPDisconnectBreakCallBack);

	os_printf("\n--------------- ESP8266_TCP_Connect_OK ---------------\n");
}



struct espconn TCPServerConn;


void ICACHE_FLASH_ATTR User_TCPServer_Init(void)
{

	TCPServerConn.type = ESPCONN_TCP;
	TCPServerConn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));
	TCPServerConn.proto.tcp->local_port = 8266;
	espconn_regist_connectcb(&TCPServerConn,TCPConnectCallBack);
	espconn_regist_reconcb(&TCPServerConn,TCPReconnectBreakCallBack);
	espconn_accept(&TCPServerConn);
	espconn_regist_time(&TCPServerConn, 300, 0);

}



void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 client_num = 0;
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];


	struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}

	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}

	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);

	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
	client_num = wifi_softap_get_station_num();
	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);
	os_printf("Number of devices connected to this WIFI = %d\n",client_num);
	if(client_num !=0)
	{
		os_printf("已经链接到WIFI 请打开TCP!\r\n");
		os_timer_disarm(&OS_Timer_1);


		//os_timer_disarm(&OS_Timer_1);

	}

}

void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 1000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //锟斤拷始锟斤拷锟斤拷锟斤拷锟斤拷
	//delay_ms(1000);
	os_printf("==========================================\r\n");
	os_printf("==========================================\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());
    os_printf("==========================================\r\n");

	AP_Init();
	OS_Time_Init();
	User_TCPServer_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}




void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```


## AP TCP CLIENT

1. 设置AP 热点

2. 配置 TCP 发送成功回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR WIFISendCallBack(void *arg)
    {
        os_printf("\nESP8266_WIFI_Send_OK\n");
    }
    ```
3. 配置 TCP 接受成功回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR WIFIRecvCallBack(void *arg, char * pdata, unsigned short len)
    {
        struct	espconn	*pesp_conn = arg;
        sint8 connectionInfoStatus;
        espconn_send(pesp_conn,	pdata,	os_strlen(pdata)
    }
    ```
4. 配置 TCP 连接成功回调函数
    **成功后直接发送数据**
    ``` cpp
    void ICACHE_FLASH_ATTR TCPConnectCallBack(void *arg)
    {
        struct	espconn	*pesp_conn = arg;

        espconn_regist_sentcb((struct espconn *)arg, WIFISendCallBack);
        espconn_regist_recvcb(pesp_conn, WIFIRecvCallBack);
        espconn_regist_disconcb((struct espconn *)arg,TCPDisconnectBreakCallBack);
        espconn_send(pesp_conn,"hello i'm esp8266 tcp client",os_strlen("hello i'm esp8266 tcp client"));
        os_printf("\n--------------- ESP8266_TCP_Connect_OK ---------------\n");
    }

    ```
5. 配置 TCP 链接中打断回调函数
    ``` cpp
    void ICACHE_FLASH_ATTR TCPReconnectBreakCallBack(void *arg,sint8 err)
    {
        os_printf("\nESP8266_TCP_Disconnect_OK\n");
        os_timer_arm(&OS_Timer_1, 3000, 1); //链接写在定时器里面 如果连接失败 尝试重新链接
    }
    

    ```
6. 配置 TCP 链接失败回调函数
    ``` cpp
   void ICACHE_FLASH_ATTR TCPDisconnectBreakCallBack(void *arg)
    {
        os_printf("\nESP8266_TCP_Disconnect_OK\n");
        os_timer_arm(&OS_Timer_1, 3000, 1);
        //链接写在定时器里面 如果连接失败 尝试重新链接
    }

   ```
7. 配置TCP SERVER
    ``` cpp
    struct espconn TCPServerConn;
    void ICACHE_FLASH_ATTR User_TCPServer_Init(void)
    {

        TCPServerConn.type = ESPCONN_TCP;
        TCPServerConn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));
        TCPServerConn.proto.tcp->local_port = 8266;
        TCPServerConn.proto.tcp->remote_port = 56500;
        TCPServerConn.proto.tcp->remote_ip[0] = 192;
        TCPServerConn.proto.tcp->remote_ip[1] = 168;
        TCPServerConn.proto.tcp->remote_ip[2] = 1;
        TCPServerConn.proto.tcp->remote_ip[3] = 2;
        espconn_regist_connectcb(&TCPServerConn,TCPConnectCallBack);
        espconn_regist_reconcb(&TCPServerConn,TCPReconnectBreakCallBack);
    }
   ```
8. 定时器回调函数
``` cpp
void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 client_num = 0;
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];


	struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}

	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}

	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);

	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
	client_num = wifi_softap_get_station_num();
	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);
	os_printf("Number of devices connected to this WIFI = %d\n",client_num);
	if(client_num !=0)
	{
		os_printf("已经链接到WIFI 请打开TCP!\r\n");
		os_timer_disarm(&OS_Timer_1);
		espconn_connect(&TCPServerConn);
	}

}

```
### 程序
``` cpp
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_TCP_SERVER"

#define ESP8266_AP_SSID "AP_TCP_SERVER"
#define ESP8266_AP_PASS "12345678a"

os_timer_t OS_Timer_1;

void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR AP_Init()
{
	struct softap_config AP_Config;
	struct dhcps_lease dhcp_Config;
	struct ip_info info;

	IP4_ADDR(&info.ip,192,168,1,1);
	IP4_ADDR(&info.gw,192,168,1,1);
	IP4_ADDR(&info.netmask,255,255,255,0);

	os_memset(&AP_Config,0,sizeof(struct softap_config));
	os_strcpy(AP_Config.ssid,ESP8266_AP_SSID);
	os_strcpy(AP_Config.password,ESP8266_AP_PASS);

	AP_Config.ssid_len = os_strlen(ESP8266_AP_SSID);
	AP_Config.channel = 1;
	AP_Config.authmode = AUTH_WPA2_PSK;
	AP_Config.ssid_hidden = 0;
	AP_Config.max_connection = 4;
	AP_Config.beacon_interval = 100;


	dhcp_Config.enable = true;
	IP4_ADDR(&dhcp_Config.start_ip,192,168,1,1);
	IP4_ADDR(&dhcp_Config.end_ip,192,168,1,100);

	wifi_softap_dhcps_stop();
	wifi_set_opmode(0x02);
	wifi_set_ip_info(SOFTAP_IF,&info);
	wifi_softap_set_dhcps_lease(&dhcp_Config);
	wifi_softap_set_config(&AP_Config);
	wifi_softap_dhcps_start();

}


void ICACHE_FLASH_ATTR WIFISendCallBack(void *arg)
{
	os_printf("\nESP8266_WIFI_Send_OK\n");
}

void ICACHE_FLASH_ATTR WIFIRecvCallBack(void *arg, char * pdata, unsigned short len)
{
	struct	espconn	*pesp_conn = arg;
	remot_info	*premot	=	NULL;
	sint8 connectionInfoStatus;

	/*connectionInfoStatus = espconn_get_connection_info(pesp_conn,&premot,0);
	if(connectionInfoStatus	==	ESPCONN_OK){
	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
	 os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
	}else if(connectionInfoStatus == ESPCONN_ARG)
	{
		os_printf("connectionInfoStatus:ESPCONN_ARG\r\n");

	}*/

	//os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
	os_printf("TCP_server_recvdata:%s\r\n",pdata);
	espconn_send(pesp_conn,	pdata,	os_strlen(pdata));
}



void ICACHE_FLASH_ATTR TCPReconnectBreakCallBack(void *arg,sint8 err)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
	os_timer_arm(&OS_Timer_1, 3000, 1);
}

void ICACHE_FLASH_ATTR TCPDisconnectBreakCallBack(void *arg)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
	os_timer_arm(&OS_Timer_1, 3000, 1);
}



void ICACHE_FLASH_ATTR TCPConnectCallBack(void *arg)
{
	struct	espconn	*pesp_conn = arg;

	espconn_regist_sentcb(pesp_conn, WIFISendCallBack);
	espconn_regist_recvcb(pesp_conn, WIFIRecvCallBack);
	espconn_regist_disconcb(pesp_conn,TCPDisconnectBreakCallBack);
	espconn_send(pesp_conn,"hello i'm esp8266 tcp client",os_strlen("hello i'm esp8266 tcp client"));
	os_printf("\n--------------- ESP8266_TCP_Connect_OK ---------------\n");
	//os_timer_disarm(&OS_Timer_1);
}



struct espconn TCPServerConn;


void ICACHE_FLASH_ATTR User_TCPServer_Init(void)
{

	TCPServerConn.type = ESPCONN_TCP;
	TCPServerConn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));
	TCPServerConn.proto.tcp->local_port = 8266;
	TCPServerConn.proto.tcp->remote_port = 56500;
	TCPServerConn.proto.tcp->remote_ip[0] = 192;
	TCPServerConn.proto.tcp->remote_ip[1] = 168;
	TCPServerConn.proto.tcp->remote_ip[2] = 1;
	TCPServerConn.proto.tcp->remote_ip[3] = 2;
	espconn_regist_connectcb(&TCPServerConn,TCPConnectCallBack);
	espconn_regist_reconcb(&TCPServerConn,TCPReconnectBreakCallBack);

	//espconn_accept(&TCPServerConn);
	//espconn_regist_time(&TCPServerConn, 300, 0);// 这个只作为服务端的时候用 判断client 超时时间

}



void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 client_num = 0;
	struct ip_info ST_ESP8266_IP;
	u8  ESP8266_IP[4];


	struct station_info * station = wifi_softap_get_station_info();
	struct station_info *next_station;
	while (station) {
		//system_soft_wdt_feed();
		os_printf("bssid : %02x:%02x:%02x:%02x:%02x:%02x, ip : %d.%d.%d.%d/n", MAC2STR(station->bssid),
		IP2STR(&station->ip));
		station = STAILQ_NEXT(station, next);
		os_free(station);
		station	=	next_station;
	}

	switch(wifi_get_opmode())
	{
		case 0x01:	os_printf("\nESP8266_Mode = Station\n");		break;
		case 0x02:	os_printf("\nESP8266_Mode = SoftAP\n");			break;
		case 0x03:	os_printf("\nESP8266_Mode = Station+SoftAP\n");	break;
	}

	wifi_get_ip_info(SOFTAP_IF,&ST_ESP8266_IP);

	ESP8266_IP[0] = ST_ESP8266_IP.ip.addr;
	ESP8266_IP[1] = ST_ESP8266_IP.ip.addr>>8;
	ESP8266_IP[2] = ST_ESP8266_IP.ip.addr>>16;
	ESP8266_IP[3] = ST_ESP8266_IP.ip.addr>>24;
	client_num = wifi_softap_get_station_num();
	os_printf("ESP8266_IP = %d.%d.%d.%d\n",ESP8266_IP[0],ESP8266_IP[1],ESP8266_IP[2],ESP8266_IP[3]);
	os_printf("Number of devices connected to this WIFI = %d\n",client_num);
	if(client_num !=0)
	{
		os_printf("已经链接到WIFI 请打开TCP!\r\n");
		os_timer_disarm(&OS_Timer_1);
		espconn_connect(&TCPServerConn);


		//os_timer_disarm(&OS_Timer_1);

	}

}

void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 5000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //锟斤拷始锟斤拷锟斤拷锟斤拷锟斤拷
	//delay_ms(1000);
	os_printf("==========================================\r\n");
	os_printf("==========================================\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());
    os_printf("==========================================\r\n");

	AP_Init();
	OS_Time_Init();
	User_TCPServer_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}




void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```

## STATION MODE

1. 设置8266模式为station MODE
	
	>wifi_set_opmode(0x01);
2. 设置静态IP  也可以不设置
	``` cpp
	struct ip_info info;
	wifi_station_dhcpc_stop();
	IP4_ADDR(&info.ip,192,168,1,154); //设置station自己的地址
	IP4_ADDR(&info.gw,192,168,1,254);// 设置网关地址
	IP4_ADDR(&info.netmask,255,255,255,0);//设置子网掩码
	wifi_set_ip_info(STATION_IF,&info);//作为STA模式 主机的
	```
3. 配置要链接的AP
	``` cpp
	#define ESP8266_STA_SSID "ZESHI_2.4G_develop"
	#define ESP8266_STA_PASS "YINSHO_WIFI_a8c17d13"
	struct station_config STA_Config;
	os_memset(&STA_Config,0,sizeof(struct station_config));
	os_strcpy(STA_Config.ssid,ESP8266_STA_SSID);
	os_strcpy(STA_Config.password,ESP8266_STA_PASS);
	wifi_station_set_config(&STA_Config); //设置相关参数
	```
4. 定时器 配置 判断是否正确链接到IP
	``` cpp
	os_timer_t OS_Timer_1;
	void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
	{
		uint8 WIFI_STA_Connect;
		struct ip_info esp8266info;
		uint8 esp8266_ip[4];
		/*enum{
			STATION_IDLE	=	0,
			STATION_CONNECTING,
			STATION_WRONG_PASSWORD,
			STATION_NO_AP_FOUND,
			STATION_CONNECT_FAIL,
			STATION_GOT_IP
		};*/
		WIFI_STA_Connect = wifi_station_get_connect_status();
		switch(WIFI_STA_Connect)
		{
			case STATION_IDLE:
				os_printf("WIFI STATION_IDLE\r\n");
				break;
			case STATION_CONNECTING:
				os_printf("WIFI STATION_CONNECTING\r\n");
				break;
			case STATION_WRONG_PASSWORD:
				os_printf("WIFI STATION_WRONG_PASSWORD\r\n");
				break;
			case STATION_NO_AP_FOUND:
				os_printf("WIFI STATION_NO_AP_FOUND\r\n");
				break;
			case STATION_CONNECT_FAIL:
				os_printf("WIFI STATION_CONNECT_FAIL\r\n");
				break;
			case STATION_GOT_IP:
				os_printf("WIFI STATION_GOT_IP\r\n");
				wifi_get_ip_info(STATION_IF,&esp8266info);
				esp8266_ip[0] = esp8266info.ip.addr;
				esp8266_ip[1] = esp8266info.ip.addr >> 8;
				esp8266_ip[2] = esp8266info.ip.addr >> 16;
				esp8266_ip[3] = esp8266info.ip.addr >> 24;
				os_printf("esp8266 STA IP: %d.%d.%d.%d \r\n",
						esp8266_ip[0],
						esp8266_ip[1],
						esp8266_ip[2],
						esp8266_ip[3]
				);
				break;
		}
	```



	}
	void OS_Time_Init(void)
	{
		os_timer_disarm(&OS_Timer_1);
		os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
		os_timer_arm(&OS_Timer_1, 3000, 1);
	}
	```
### 程序
	``` cpp
	/* ESPRESSIF MIT License
	*
	* Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
	*
	* Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
	* it is free of charge, to any person obtaining a copy of this software and associated
	* documentation files (the "Software"), to deal in the Software without restriction, including
	* without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	* and/or sell copies of the Software, and to permit persons to whom the Software is furnished
	* to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in all copies or
	* substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	*
	*/
	
	#include "ets_sys.h"
	#include "osapi.h"
	#include "user_interface.h"
	#include "driver/uart.h"
	#include "c_types.h"
	#include "mem.h"
	#include "os_type.h"
	#include "osapi.h"
	#include "queue.h"
	#include "ip_addr.h"
	#include "espconn.h"
	#include "eagle_soc.h"
	
	#define ProjectName "AP_MODE"
	
	#define ESP8266_STA_SSID "ZESHI_2.4G_develop"
	#define ESP8266_STA_PASS "YINSHO_WIFI_a8c17d13"
	/*
	SSID:	ZESHI_2.4G_develop
	PASS:	YINSHO_WIFI_a8c17d13
	*/
	
	os_timer_t OS_Timer_1;
	void ICACHE_FLASH_ATTR Station_Mode_Init(void)
	{
		struct ip_info info;
		struct station_config STA_Config;
		wifi_set_opmode(0x01);// 配置 esp8266 模式为 station 模式
		// station 模式下 会自动分配 dhcp 所以不用配置
		// 也可以手动配置IP地址 建议在第一次获取完毕后 保存这个地址
		wifi_station_dhcpc_stop();
		IP4_ADDR(&info.ip,192,168,1,154); //设置station自己的地址
		IP4_ADDR(&info.gw,192,168,1,254);// 设置网关地址
		IP4_ADDR(&info.netmask,255,255,255,0);//设置子网掩码
		wifi_set_ip_info(STATION_IF,&info);//作为STA模式 主机的
	
		os_memset(&STA_Config,0,sizeof(struct station_config));
		os_strcpy(STA_Config.ssid,ESP8266_STA_SSID);
		os_strcpy(STA_Config.password,ESP8266_STA_PASS);
		wifi_station_set_config(&STA_Config); //设置相关参数



	}
	void ICACHE_FLASH_ATTR delay_ms(uint16 t);
	void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
	{
		uint8 WIFI_STA_Connect;
		struct ip_info esp8266info;
		uint8 esp8266_ip[4];
	/*	enum{
			STATION_IDLE	=	0,
			STATION_CONNECTING,
			STATION_WRONG_PASSWORD,
			STATION_NO_AP_FOUND,
			STATION_CONNECT_FAIL,
			STATION_GOT_IP
		};*/
		WIFI_STA_Connect = wifi_station_get_connect_status();
		switch(WIFI_STA_Connect)
		{
			case STATION_IDLE:
				os_printf("WIFI STATION_IDLE\r\n");
				break;
			case STATION_CONNECTING:
				os_printf("WIFI STATION_CONNECTING\r\n");
				break;
			case STATION_WRONG_PASSWORD:
				os_printf("WIFI STATION_WRONG_PASSWORD\r\n");
				break;
			case STATION_NO_AP_FOUND:
				os_printf("WIFI STATION_NO_AP_FOUND\r\n");
				break;
			case STATION_CONNECT_FAIL:
				os_printf("WIFI STATION_CONNECT_FAIL\r\n");
				break;
			case STATION_GOT_IP:
				os_printf("WIFI STATION_GOT_IP\r\n");
				wifi_get_ip_info(STATION_IF,&esp8266info);
	
				esp8266_ip[0] = esp8266info.ip.addr;
				esp8266_ip[1] = esp8266info.ip.addr >> 8;
				esp8266_ip[2] = esp8266info.ip.addr >> 16;
				esp8266_ip[3] = esp8266info.ip.addr >> 24;
	
				os_printf("esp8266 STA IP: %d.%d.%d.%d \r\n",
						esp8266_ip[0],
						esp8266_ip[1],
						esp8266_ip[2],
						esp8266_ip[3]
				);



				break;
		}



	}
	void OS_Time_Init(void)
	{
		os_timer_disarm(&OS_Timer_1);
		os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
		os_timer_arm(&OS_Timer_1, 3000, 1);
	}



	/******************************************************************************
	* FunctionName : user_init
	* Description  : entry of user application, init user function here
	* Parameters   : none
	* Returns      : none
	*******************************************************************************/
	void ICACHE_FLASH_ATTR
	user_init(void)
	{
		uart_init(115200,115200); //锟斤拷始锟斤拷锟斤拷锟斤拷锟斤拷
		//delay_ms(1000);
		os_printf("\r\n");
		os_printf("project name:%s\r\n",ProjectName);
		os_printf("SDK version:%s\r\n", system_get_sdk_version());
		Station_Mode_Init();
		OS_Time_Init();
	}
	
	uint32 ICACHE_FLASH_ATTR
	user_rf_cal_sector_set(void)
	
	{
		enum flash_size_map size_map = system_get_flash_size_map();
		uint32 rf_cal_sec = 0;
		switch (size_map) {
			case FLASH_SIZE_4M_MAP_256_256:
				rf_cal_sec = 128 - 5;
				break;
	
			case FLASH_SIZE_8M_MAP_512_512:
				rf_cal_sec = 256 - 5;
	
				break;
	
			case FLASH_SIZE_16M_MAP_512_512:
				rf_cal_sec = 512 - 5;
	
				break;
			case FLASH_SIZE_16M_MAP_1024_1024:
				rf_cal_sec = 512 - 5;
	
				break;
	
			case FLASH_SIZE_32M_MAP_512_512:
				rf_cal_sec = 1024 - 5;
	
				break;
			case FLASH_SIZE_32M_MAP_1024_1024:
				rf_cal_sec = 1024 - 5;
	
				break;
	
			case FLASH_SIZE_64M_MAP_1024_1024:
				rf_cal_sec = 2048 - 5;
	
				break;
			case FLASH_SIZE_128M_MAP_1024_1024:
				rf_cal_sec = 4096 - 5;
	
				break;
			default:
				rf_cal_sec = 0;
	
				break;
		}
	
		return rf_cal_sec;
	}




	void ICACHE_FLASH_ATTR
	user_rf_pre_init(void)
	{
	}
	
	void ICACHE_FLASH_ATTR delay_ms(uint16 t)
	{
		while(t --)
		{
			os_delay_us(1000);
		}
	}
	
	```
	
## STA UDP SERVER
1. 设置STATION 参数 
**和上面那部一样**
其余参数设置 和 AP下的 都一样
## STA UDP CLIENT
1. 设置STATION 参数 
**和上面那部一样**
其余参数设置 和 AP下的 都一样

### 代码
``` cpp
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_MODE"

#define ESP8266_STA_SSID "ZESHI_2.4G_develop"
#define ESP8266_STA_PASS "YINSHO_WIFI_a8c17d13"
/*
SSID:	ZESHI_2.4G_develop
PASS:	YINSHO_WIFI_a8c17d13
*/

os_timer_t OS_Timer_1;
struct espconn udp_server_conn; //����UPD��������ʼ���ṹ��
void ICACHE_FLASH_ATTR Station_Mode_Init(void)
{
	// station ģʽ�� ���Զ����� dhcp ���Բ�������
	// Ҳ�����ֶ�����IP��ַ �����ڵ�һ�λ�ȡ��Ϻ� ���������ַ
	struct ip_info info;
	struct station_config STA_Config;
	wifi_set_opmode(0x01);// ���� esp8266 ģʽΪ station ģʽ
	wifi_station_dhcpc_stop();
	IP4_ADDR(&info.ip,192,168,1,154); //����station�Լ��ĵ�ַ
	IP4_ADDR(&info.gw,192,168,1,254);// �������ص�ַ
	IP4_ADDR(&info.netmask,255,255,255,0);//������������
	wifi_set_ip_info(STATION_IF,&info);//��ΪSTAģʽ ������
	os_memset(&STA_Config,0,sizeof(struct station_config));
	os_strcpy(STA_Config.ssid,ESP8266_STA_SSID);
	os_strcpy(STA_Config.password,ESP8266_STA_PASS);
	wifi_station_set_config(&STA_Config); //������ز���
}
void ICACHE_FLASH_ATTR udp_server_recv_cb(void *arg, char *pdata, unsigned short len)
{
    struct	espconn	*pesp_conn	=	arg; //��ȡ�ص�������ڵ� UDP ���Խṹ��
    remot_info	*premot	=	NULL;
     if	(espconn_get_connection_info(pesp_conn,&premot,0)	==	ESPCONN_OK){
    	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
    	 //pesp_conn->proto.tcp->remote_port	=	58050;
    	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
    	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
    	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
    	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
    	 //espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));
     }

    espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));//���ؽ��ܵ�������
    os_printf("UDP SERVER RECEIV:%s\r\n",pdata);
    os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
}
void ICACHE_FLASH_ATTR udp_server_send_cb(void *arg)
{
	os_printf("udp send success!!\r\n");
}
void ICACHE_FLASH_ATTR Station_UDP_Init(void)
{
	udp_server_conn.type = ESPCONN_UDP;
	udp_server_conn.proto.udp = (esp_udp *)os_zalloc(sizeof(esp_udp)); //����һ���ڴ�� UDP ����ʼ��
	udp_server_conn.proto.udp->local_port = 8266;// UDP�������˿�
	udp_server_conn.proto.udp->remote_ip[0] = 192;
	udp_server_conn.proto.udp->remote_ip[1] = 168;
	udp_server_conn.proto.udp->remote_ip[2] = 1;
	udp_server_conn.proto.udp->remote_ip[3] = 82;
	udp_server_conn.proto.udp->remote_port = 52189;

	espconn_regist_sentcb(&udp_server_conn,udp_server_send_cb); //�����ص�
	espconn_regist_recvcb(&udp_server_conn,udp_server_recv_cb); //�����ص�
}
void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 WIFI_STA_Connect;
	struct ip_info esp8266info;
	uint8 esp8266_ip[4];
	/*enum{
		STATION_IDLE	=	0,
		STATION_CONNECTING,
		STATION_WRONG_PASSWORD,
		STATION_NO_AP_FOUND,
		STATION_CONNECT_FAIL,
		STATION_GOT_IP
	};*/
	WIFI_STA_Connect = wifi_station_get_connect_status();
	switch(WIFI_STA_Connect)
	{
		case STATION_IDLE:
			os_printf("WIFI STATION_IDLE\r\n");
			break;
		case STATION_CONNECTING:
			os_printf("WIFI STATION_CONNECTING\r\n");
			break;
		case STATION_WRONG_PASSWORD:
			os_printf("WIFI STATION_WRONG_PASSWORD\r\n");
			break;
		case STATION_NO_AP_FOUND:
			os_printf("WIFI STATION_NO_AP_FOUND\r\n");
			break;
		case STATION_CONNECT_FAIL:
			os_printf("WIFI STATION_CONNECT_FAIL\r\n");
			break;
		case STATION_GOT_IP:
			os_printf("WIFI STATION_GOT_IP\r\n");
			wifi_get_ip_info(STATION_IF,&esp8266info);

			esp8266_ip[0] = esp8266info.ip.addr;
			esp8266_ip[1] = esp8266info.ip.addr >> 8;
			esp8266_ip[2] = esp8266info.ip.addr >> 16;
			esp8266_ip[3] = esp8266info.ip.addr >> 24;

			os_printf("esp8266 STA IP: %d.%d.%d.%d \r\n",
					esp8266_ip[0],
					esp8266_ip[1],
					esp8266_ip[2],
					esp8266_ip[3]
			);

			switch(espconn_create(&udp_server_conn))//��UDP
			{
				case ESPCONN_ISCONN:
					os_printf("UDP ���ӳɹ� \r\n");
					os_printf("esp8266 STA UDP:created!\r\n");
					os_timer_disarm(&OS_Timer_1);
					os_printf("&OS_Timer_1 Disabled\r\n");

					espconn_sendto(&udp_server_conn,"LED ON CLIENT",os_strlen("LED ON CLIENT"));

					break;
				case  ESPCONN_ARG:
									os_printf("UDP ESPCONN_ARG \r\n");

									break;
				case ESPCONN_MEM:
									os_printf("UDP ESPCONN_MEM \r\n");

									break;
				default:break;
			}



			break;
	}



}
void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 3000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //��ʼ��������
	//delay_ms(1000);
	os_printf("\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());
    Station_Mode_Init();
    OS_Time_Init();
    Station_UDP_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}

void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```

## STA TCP SERVER
1. 设置STATION 参数 
**和上面那部一样**
其余参数设置 和 AP下的 都一样
## STA TCP CLIENT
1. 设置STATION 参数 
**和上面那部一样**
其余参数设置 和 AP下的 都一样

### 代码
``` cpp
/* ESPRESSIF MIT License
 *
 * Copyright (c) 2016 <ESPRESSIF SYSTEMS (SHANGHAI) PTE LTD>
 *
 * Permission is hereby granted for use on ESPRESSIF SYSTEMS ESP8266 only, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "AP_MODE"

#define ESP8266_STA_SSID "ZESHI_2.4G_develop"
#define ESP8266_STA_PASS "YINSHO_WIFI_a8c17d13"
/*
SSID:	ZESHI_2.4G_develop
PASS:	YINSHO_WIFI_a8c17d13
*/

os_timer_t OS_Timer_1;
struct espconn TCPServerConn;; //����TCP��������ʼ���ṹ��
void ICACHE_FLASH_ATTR Station_Mode_Init(void)
{
	// station ģʽ�� ���Զ����� dhcp ���Բ�������
	// Ҳ�����ֶ�����IP��ַ �����ڵ�һ�λ�ȡ��Ϻ� ���������ַ
	struct ip_info info;
	struct station_config STA_Config;
	wifi_set_opmode(0x01);// ���� esp8266 ģʽΪ station ģʽ
	wifi_station_dhcpc_stop();
	IP4_ADDR(&info.ip,192,168,1,154); //����station�Լ��ĵ�ַ
	IP4_ADDR(&info.gw,192,168,1,254);// �������ص�ַ
	IP4_ADDR(&info.netmask,255,255,255,0);//������������
	wifi_set_ip_info(STATION_IF,&info);//��ΪSTAģʽ ������
	os_memset(&STA_Config,0,sizeof(struct station_config));
	os_strcpy(STA_Config.ssid,ESP8266_STA_SSID);
	os_strcpy(STA_Config.password,ESP8266_STA_PASS);
	wifi_station_set_config(&STA_Config); //������ز���
}

void ICACHE_FLASH_ATTR TCP_server_recv_cb(void *arg, char *pdata, unsigned short len)
{
    struct	espconn	*pesp_conn	=	arg; //��ȡ�ص�������ڵ� UDP ���Խṹ��
    remot_info	*premot	=	NULL;
     if	(espconn_get_connection_info(pesp_conn,&premot,0)	==	ESPCONN_OK){
    	 pesp_conn->proto.tcp->remote_port	=	premot->remote_port;
    	 //pesp_conn->proto.tcp->remote_port	=	58050;
    	 pesp_conn->proto.tcp->remote_ip[0]	=	premot->remote_ip[0];
    	 pesp_conn->proto.tcp->remote_ip[1]	=	premot->remote_ip[1];
    	 pesp_conn->proto.tcp->remote_ip[2]	=	premot->remote_ip[2];
    	 pesp_conn->proto.tcp->remote_ip[3]	=	premot->remote_ip[3];
    	 //espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));
     }

    espconn_sent(pesp_conn,	pdata,	os_strlen(pdata));//���ؽ��ܵ�������
    os_printf("TCP SERVER RECEIV:%s\r\n",pdata);
    os_printf("IPADDR:%d,%d,%d,%d:%d\r\n",premot->remote_ip[0],premot->remote_ip[1],premot->remote_ip[2],premot->remote_ip[3],premot->remote_port);
}
void ICACHE_FLASH_ATTR TCP_server_send_cb(void *arg)
{
	os_printf("TCP send success!!\r\n");
}

void ICACHE_FLASH_ATTR TCPReconnectBreakCallBack(void *arg,sint8 err)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
	os_timer_arm(&OS_Timer_1, 3000, 1);
}

void ICACHE_FLASH_ATTR TCPDisconnectBreakCallBack(void *arg)
{
	os_printf("\nESP8266_TCP_Disconnect_OK\n");
	os_timer_arm(&OS_Timer_1, 3000, 1);
}



void ICACHE_FLASH_ATTR TCPConnectCallBack(void *arg)
{
	struct	espconn	*pesp_conn = arg;

	espconn_regist_sentcb(pesp_conn, TCP_server_send_cb);
	espconn_regist_recvcb(pesp_conn, TCP_server_recv_cb);

	espconn_regist_disconcb(pesp_conn,TCPDisconnectBreakCallBack);
	espconn_send(pesp_conn,"hello i'm esp8266 tcp client",os_strlen("hello i'm esp8266 tcp client"));
	os_printf("\n--------------- ESP8266_TCP_Connect_OK ---------------\n");
	//os_timer_disarm(&OS_Timer_1);
}

void ICACHE_FLASH_ATTR Station_TCP_Init(void)
{
	TCPServerConn.type = ESPCONN_TCP;
	TCPServerConn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));
	TCPServerConn.proto.tcp->local_port = 8266;
	espconn_regist_connectcb(&TCPServerConn,TCPConnectCallBack);
	espconn_regist_reconcb(&TCPServerConn,TCPReconnectBreakCallBack);
	espconn_accept(&TCPServerConn);
	espconn_regist_time(&TCPServerConn, 300, 0);
}
void ICACHE_FLASH_ATTR delay_ms(uint16 t);
void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 WIFI_STA_Connect;
	struct ip_info esp8266info;
	uint8 esp8266_ip[4];
	/*enum{
		STATION_IDLE	=	0,
		STATION_CONNECTING,
		STATION_WRONG_PASSWORD,
		STATION_NO_AP_FOUND,
		STATION_CONNECT_FAIL,
		STATION_GOT_IP
	};*/
	WIFI_STA_Connect = wifi_station_get_connect_status();
	switch(WIFI_STA_Connect)
	{
		case STATION_IDLE:
			os_printf("WIFI STATION_IDLE\r\n");
			break;
		case STATION_CONNECTING:
			os_printf("WIFI STATION_CONNECTING\r\n");
			break;
		case STATION_WRONG_PASSWORD:
			os_printf("WIFI STATION_WRONG_PASSWORD\r\n");
			break;
		case STATION_NO_AP_FOUND:
			os_printf("WIFI STATION_NO_AP_FOUND\r\n");
			break;
		case STATION_CONNECT_FAIL:
			os_printf("WIFI STATION_CONNECT_FAIL\r\n");
			break;
		case STATION_GOT_IP:
			os_printf("WIFI STATION_GOT_IP\r\n");
			wifi_get_ip_info(STATION_IF,&esp8266info);

			esp8266_ip[0] = esp8266info.ip.addr;
			esp8266_ip[1] = esp8266info.ip.addr >> 8;
			esp8266_ip[2] = esp8266info.ip.addr >> 16;
			esp8266_ip[3] = esp8266info.ip.addr >> 24;

			os_printf("esp8266 STA IP: %d.%d.%d.%d \r\n",
					esp8266_ip[0],
					esp8266_ip[1],
					esp8266_ip[2],
					esp8266_ip[3]
			);
			os_timer_disarm(&OS_Timer_1);

			break;
		default:;break;






	}



}
void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 3000, 1);
}



/******************************************************************************
 * FunctionName : user_init
 * Description  : entry of user application, init user function here
 * Parameters   : none
 * Returns      : none
*******************************************************************************/
void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200); //��ʼ��������
	//delay_ms(1000);
	os_printf("\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());
    Station_Mode_Init();
    OS_Time_Init();
    Station_TCP_Init();
}

uint32 ICACHE_FLASH_ATTR
user_rf_cal_sector_set(void)

{
    enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:
            rf_cal_sec = 128 - 5;
            break;

        case FLASH_SIZE_8M_MAP_512_512:
            rf_cal_sec = 256 - 5;

            break;

        case FLASH_SIZE_16M_MAP_512_512:
            rf_cal_sec = 512 - 5;

            break;
        case FLASH_SIZE_16M_MAP_1024_1024:
            rf_cal_sec = 512 - 5;

            break;

        case FLASH_SIZE_32M_MAP_512_512:
            rf_cal_sec = 1024 - 5;

            break;
        case FLASH_SIZE_32M_MAP_1024_1024:
            rf_cal_sec = 1024 - 5;

            break;

        case FLASH_SIZE_64M_MAP_1024_1024:
            rf_cal_sec = 2048 - 5;

            break;
        case FLASH_SIZE_128M_MAP_1024_1024:
            rf_cal_sec = 4096 - 5;

            break;
        default:
            rf_cal_sec = 0;

            break;
    }

    return rf_cal_sec;
}

void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
}

void ICACHE_FLASH_ATTR delay_ms(uint16 t)
{
	while(t --)
	{
		os_delay_us(1000);
	}
}

```

## DNS 

**如何通过域名来获取IP地址**


1. SAT 模式 接入 WIFI 确保已经链接网络

**有几个比较重要的点**

- 确保网关正确
- netmask 正确

2. 调用DNS 获取函数

**这个函数中要确保有 TCP 链接的结构体**
**获取到IP的结构体**
**字符串域名**
**DNS获取回调函数**
**DNS的获取不能直接卸载 user_init() 初始化函数中**
**espconn_gethostbyname 这个函数卸载 定时器回调函数中会比较好**
	``` cpp
	err_t ICACHE_FLASH_ATTR
	espconn_gethostbyname(struct espconn *pespconn, const char *hostname, ip_addr_t *addr, dns_found_callback found)
	{
		return dns_gethostbyname(hostname, addr, found, pespconn);
	}
	```
3. 写DNS获取回调函数
	```cpp
	void ICACHE_FLASH_ATTR DNS_Found_Callback(const	char *name,	ip_addr_t *ipaddr, void	*arg)
	{
		struct espconn * T_arg = (struct espconn *)arg;
		if(ipaddr == NULL)
		{
			os_printf("\r\n---- DomainName Analyse Failed ----\r\n");
			return;
		}else if(ipaddr != NULL && ipaddr->addr != 0)
		{
			os_printf("\r\n---- DomainName Analyse Succeed ----\r\n");
			os_printf("user_esp_platform_dns_found	%d.%d.%d.%d/n",
			*((uint8	*)&ipaddr->addr),	*((uint8	*)&ipaddr->addr	+	1),
			*((uint8	*)&ipaddr->addr	+	2),	*((uint8	*)&ipaddr->addr	+	3));
		}
	}
	```
### 程序
``` cpp
#include "ets_sys.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "c_types.h"
#include "mem.h"
#include "os_type.h"
#include "osapi.h"
#include "queue.h"
#include "ip_addr.h"
#include "espconn.h"
#include "eagle_soc.h"

#define ProjectName "DNS"

#define DNS_SERVER "www.baidu.com"

#define ESP8266_STA_SSID "ZESHI_2.4G_develop"
#define ESP8266_STA_PASS "YINSHO_WIFI_a8c17d13"

/*
SSID:	ZESHI_2.4G_develop
PASS:	YINSHO_WIFI_a8c17d13
*/

os_timer_t OS_Timer_1;
struct espconn tcp_client_conn; //声明TCP服务器初始化结构体
struct espconn ST_NetCon;
ip_addr_t IP_Server;


void ICACHE_FLASH_ATTR Station_Mode_Init(void)
{
	// station 模式下 会自动分配 dhcp 所以不用配置
	// 也可以手动配置IP地址 建议在第一次获取完毕后 保存这个地址
	struct ip_info info;
	struct station_config STA_Config;
	wifi_set_opmode(0x01);// 配置 esp8266 模式为 station 模式
	//wifi_station_dhcpc_stop();
	//IP4_ADDR(&info.ip,192,168,1,154); //设置station自己的地址
	//IP4_ADDR(&info.gw,192,168,100,254);// 设置网关地址
	//IP4_ADDR(&info.netmask,255,255,255,0);//设置子网掩码
	//wifi_set_ip_info(STATION_IF,&info);//作为STA模式 主机的
	os_memset(&STA_Config,0,sizeof(struct station_config));
	os_strcpy(STA_Config.ssid,ESP8266_STA_SSID);
	os_strcpy(STA_Config.password,ESP8266_STA_PASS);
	wifi_station_set_config(&STA_Config); //设置相关参数
}



void ICACHE_FLASH_ATTR DNS_Found_Callback(const	char *name,	ip_addr_t *ipaddr, void	*arg)
{
	struct espconn * T_arg = (struct espconn *)arg;
	if(ipaddr == NULL)
	{
		os_printf("\r\n---- DomainName Analyse Failed ----\r\n");
		return;
	}else if(ipaddr != NULL && ipaddr->addr != 0)
	{
		os_printf("\r\n---- DomainName Analyse Succeed ----\r\n");
		os_printf("user_esp_platform_dns_found	%d.%d.%d.%d/n",
		*((uint8	*)&ipaddr->addr),	*((uint8	*)&ipaddr->addr	+	1),
		*((uint8	*)&ipaddr->addr	+	2),	*((uint8	*)&ipaddr->addr	+	3));
	}
}

void ICACHE_FLASH_ATTR OS_Timer_1_cb(void)
{
	uint8 WIFI_STA_Connect;
	struct ip_info esp8266info;
	uint8 esp8266_ip[4];
	WIFI_STA_Connect = wifi_station_get_connect_status();
	if(WIFI_STA_Connect == STATION_GOT_IP)
	{
		os_printf("WIFI STATION_GOT_IP\r\n");
		wifi_get_ip_info(STATION_IF,&esp8266info);
		esp8266_ip[0] = esp8266info.ip.addr;
		esp8266_ip[1] = esp8266info.ip.addr >> 8;
		esp8266_ip[2] = esp8266info.ip.addr >> 16;
		esp8266_ip[3] = esp8266info.ip.addr >> 24;
		os_printf("esp8266 STA IP: %d.%d.%d.%d \r\n",
				esp8266_ip[0],
				esp8266_ip[1],
				esp8266_ip[2],
				esp8266_ip[3]
		);
		os_timer_disarm(&OS_Timer_1);

		tcp_client_conn.type = ESPCONN_TCP ;
		tcp_client_conn.proto.tcp = (esp_tcp *)os_zalloc(sizeof(esp_tcp));

		tcp_client_conn.proto.tcp->local_port = 8266;
		tcp_client_conn.proto.tcp->remote_port = 80;


		espconn_gethostbyname(&tcp_client_conn, "www.baidu.com", &IP_Server, DNS_Found_Callback);

	}


}
void OS_Time_Init(void)
{
	os_timer_disarm(&OS_Timer_1);
	os_timer_setfn(&OS_Timer_1,(os_timer_func_t *)OS_Timer_1_cb, NULL);
	os_timer_arm(&OS_Timer_1, 3000, 1);
}

void ICACHE_FLASH_ATTR
user_init(void)
{
	uart_init(115200,115200);
	os_printf("\r\n");
	os_printf("project name:%s\r\n",ProjectName);
    os_printf("SDK version:%s\r\n", system_get_sdk_version());
    Station_Mode_Init();
    OS_Time_Init();
}


```



